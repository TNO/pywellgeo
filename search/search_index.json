{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyWellGeo","text":"<p>PyWellGeo is a Python library for advanced well trajectory modeling, well data handling, and geothermal engineering workflows. It provides tools for representing, analyzing, and visualizing complex well architectures, including multi-branch wells, and supports a variety of input formats and engineering calculations.</p>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li>Flexible well trajectory modeling (vertical, deviated, multi-branch)</li> <li>Well data utilities (water properties, constants, DC1D well models)</li> <li>Well tree structures for advanced branching and perforation logic</li> <li>Geometric transformations (azimuth/dip, vector math)</li> <li>Integration with geothermal techno-economic workflows</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<p>Browse the API documentation for each submodule below.</p>"},{"location":"api/transformations/azimdip/","title":"pywellgeo.transformations","text":""},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip","title":"pywellgeo.transformations.azim_dip.AzimDip","text":"<p>AzimDip class, spherical coordinates and its conversion to vector notation using the following convention</p> <ul> <li>azmimuth = 0 corresponds to positive y-axis</li> <li>azimuth = 90 corresponds to positive x-axis</li> <li>dip &gt;0  corresponds to negative z axis</li> </ul>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.azim","title":"azim  <code>property</code> <code>writable</code>","text":"<pre><code>azim\n</code></pre> <p>degrees of the azimuth (from 0 to 360, 0 is north)</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.dip","title":"dip  <code>property</code> <code>writable</code>","text":"<pre><code>dip\n</code></pre> <p>degrees of the dip (from -90 to 90, 0 is horizontal)</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.__init__","title":"__init__","text":"<pre><code>__init__(azim: Union[float64, int], dip: Union[float64, int]) -&gt; None\n</code></pre> <p>instantiate an azim, dip  object</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.copy","title":"copy  <code>classmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>create a deep copy of the object</p> <p>:return: deep copy of the object</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.from_vector","title":"from_vector  <code>classmethod</code>","text":"<pre><code>from_vector(dipvec: ndarray) -&gt; AzimDip\n</code></pre> <p>instantiate an azim dip vector object from a dip vector</p> <p>:param  dipvec 3D vector (np.array)</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.azimdip2Vector","title":"azimdip2Vector","text":"<pre><code>azimdip2Vector(n: ndarray = None) -&gt; ndarray\n</code></pre> <p>convert azimuth and dip spherical coordinates to a cartesianvector in the dip direction</p> <p>:return  cartesian coordinates of the azimdip directon(x, y, z)</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.azimdip2normal","title":"azimdip2normal","text":"<pre><code>azimdip2normal(n: ndarray = None) -&gt; ndarray\n</code></pre> <p>convert azimuth and dip spherical coordinates to a cartesianvector in the normal direction of the plane dipping in azim and dip</p> <p>:return  cartesian coordinates of the normal directon(x, y, z)</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.swapnormal","title":"swapnormal","text":"<pre><code>swapnormal() -&gt; None\n</code></pre> <p>swap to the normal of azim,dip plane (azim,dip) -&gt; (azim+180, 90-dip), preserving sign of dip</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.swapsign","title":"swapsign","text":"<pre><code>swapsign()\n</code></pre> <p>swap the sign of the dip. (azim,dip) -&gt; (azim+180, -dip)</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.plane2normal_ref","title":"plane2normal_ref","text":"<pre><code>plane2normal_ref()\n</code></pre> <p>convert azimuth and dip spherical coordinates to its normal or vice versa</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.plane2normal","title":"plane2normal","text":"<pre><code>plane2normal() -&gt; None\n</code></pre> <p>convert azimuth and dip spherical coordinates to its normal or vice versa, forcing dip&gt;0</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.normalize_vector","title":"normalize_vector  <code>classmethod</code>","text":"<pre><code>normalize_vector(vec: ndarray) -&gt; ndarray\n</code></pre> <p>normalize a 3D vector</p> <p>:param vec: np array with 3 elements :return: normalized vector</p>"},{"location":"api/transformations/azimdip/#pywellgeo.transformations.azim_dip.AzimDip.test","title":"test  <code>classmethod</code>","text":"<pre><code>test()\n</code></pre> <p>test the AzimDip class</p>"},{"location":"api/transformations/coordinate_transformation/","title":"pywellgeo.transformations","text":""},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation","title":"pywellgeo.transformations.coordinate_transformation.CoordinateTransformation","text":"<p>class to support coordinate transformations</p> <p>transformation is determined by rotated basis and global origin spec</p> <p>the transformed and rotated basis is based on</p> <p>x(local) =  R T x(global)</p> <ul> <li>x = homogeneous coordinates (x,y,z,1)</li> <li>T = 4x4 translation matrix. This is a diagonal unit matrix with in  the fourth column the translation components  -ox,-oy,-oz , where ox,oy,oz is the orogin</li> <li>R = 4x4  unit matrix, where 3x3 first rows and columns is the rotation matrix.</li> </ul> <p>It contains in the rows the unit axes (in global coordinate system orientation)</p> <p>The initialization is performed in two possible manners:</p> <ul> <li> <p>from a definition of the plane for the local coordinates (containing two of the axes), and direction of the first axis.     The plane and first axis are defined by spherical coordinates azimdip and the pitch of the first axis in the plane     (the third corresponds to the normal to the plane and the second to the outer product of the thrid and first)</p> </li> <li> <p>from a rotated axis framework where the first two unit vectors are given</p> </li> </ul> <p>The backrotation is performed by using the inverse of RT</p> <ul> <li>x(global) =  (RT)-1 x(local)</li> </ul>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.__init__","title":"__init__","text":"<pre><code>__init__(plane: AzimDip, origin: ndarray = np.asarray([0, 0, 0]), pitch: Union[float64, int] = 0) -&gt; None\n</code></pre> <p>initialize the coordinate transformation</p> <p>:param plane: spherical coordinates of the plane to use,                 azim/dip is the reference direction for the x-axis for pitch is 0                 y-axis is in the plane (90 degrees anticlockwise), z-axis is pointing upward</p> <p>:param origin: of the local coordinate system</p> <p>:param pitch: rotation clockwise of the local x-axis in the plane relative to the azim-dip,                 for pitch=0, 90/0 in local coordinates corresponds to the plane azim/dip in global coordinates                 for pitch=90, 0/0 in local coordinates corresponds to the plane azim/dip in global coordinates</p>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.transform2local","title":"transform2local","text":"<pre><code>transform2local(vglobal: ndarray) -&gt; ndarray\n</code></pre> <p>transform a vector from global to local coordinates</p> <p>:param vglobal: np array with 3 elements representing the vector in global coordinates :return: np array with 3 elements representing the vector in local coordinates</p>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.transform2global","title":"transform2global","text":"<pre><code>transform2global(vlocal: ndarray) -&gt; ndarray\n</code></pre> <p>transform a vector from local to global coordinates</p> <p>:param vlocal: np array with 3 elements representing the vector in local coordinates :return: np array with 3 elements representing the vector in global coordinates</p>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.transform2local_orientation","title":"transform2local_orientation","text":"<pre><code>transform2local_orientation(azimdip: AzimDip) -&gt; AzimDip\n</code></pre> <p>transform an orientation from global to local coordinates</p> <p>:param azimdip: AzimDip object representing the orientation in global coordinates :return: local AzimDip object representing the orientation in local coordinates</p>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.transform2global_orientation","title":"transform2global_orientation","text":"<pre><code>transform2global_orientation(azimdip: AzimDip) -&gt; AzimDip\n</code></pre> <p>transform an orientation from local to global coordinates</p> <p>:param azimdip: AzimDip object representing the orientation in local coordinates :return: global AzimDip object representing the orientation in global coordinates</p>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.rotx","title":"rotx","text":"<pre><code>rotx(theta)\n</code></pre> <p>rotx gives rotation matrix about X axis</p> <p>:param theta: radians angle for rotation matrix :return: rotation matrix (3x3) representing a rotation of theta radians about the x-axis</p>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.roty","title":"roty","text":"<pre><code>roty(theta: float64) -&gt; ndarray\n</code></pre> <p>roty gives rotation matrix about X axis</p> <p>:param theta: radians angle for rotation matrix :return: rotation matrix (3x3) representing a rotation of theta radians about the y-axis</p>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.rotz","title":"rotz","text":"<pre><code>rotz(theta: float64) -&gt; ndarray\n</code></pre> <p>rotz gives rotation matrix about X axis</p> <p>:param theta: radians angle for rotation matrix :return: rotation matrix   (3x3) representing a rotation of theta radians about the z-axis</p>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.plane_pitch_from_vectors","title":"plane_pitch_from_vectors  <code>classmethod</code>","text":"<pre><code>plane_pitch_from_vectors(vecx: ndarray, vec2: ndarray) -&gt; Union[Tuple[AzimDip, int], Tuple[AzimDip, float64]]\n</code></pre> <p>get the plane and pitch from two vectors, sharing the origin as starting point</p> <pre><code>:param vecx (np array) the first vector and x-axis orientation\n:param vec2 (np array) the second vector in the plane\n:return: Azimdip object representing the plane and the pitch of the x-axis in the plane\n</code></pre>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.line_plane_intersect","title":"line_plane_intersect","text":"<pre><code>line_plane_intersect(ad_ray: AzimDip, rayPoint: ndarray) -&gt; ndarray\n</code></pre> <p>calculate the intersection of line (shooting from raypoint in ad_ray direction) and the plane of self</p> <p>:param ad_ray: AzimDip object representing the direction of the line :param rayPoint: np array representing the starting point of the line</p> <p>:return: intersection point in the coordinate-system of self(its x,y,z coordinates)</p>"},{"location":"api/transformations/coordinate_transformation/#pywellgeo.transformations.coordinate_transformation.CoordinateTransformation.planes_intersect","title":"planes_intersect","text":"<pre><code>planes_intersect(b_t)\n</code></pre> <p>calculate the intersection of the two basis planes of the transformation.</p> <p>:param b_t: CoordinateTransformation object representing the other basis</p> <p>return: intersection point and AzimDip of orientation of intersection, if</p>"},{"location":"api/well_data/constants/","title":"pywellgeo.well_data","text":""},{"location":"api/well_data/constants/#pywellgeo.well_data.names_constants.Constants","title":"pywellgeo.well_data.names_constants.Constants  <code>dataclass</code>","text":"<p>This is a dataclass that contains simulation and well specific constants. It is used to store constants that are used throughout the simulation and well calculations.</p>"},{"location":"api/well_data/dc1d_well/","title":"pywellgeo.well_data","text":""},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell","title":"pywellgeo.well_data.dc1dwell","text":""},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell","title":"Dc1dwell","text":"<p>Class to calculate the productivity of a well in a confined, infinite, homogeneous reservoir</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.__init__","title":"__init__","text":"<pre><code>__init__(k: int, H: int, L: int, tvd: List[int], temp: List[Union[float, int]], salinity: List[int], skin: List[float], ahd: List[int], rw: List[float], roughness: float, tgrad: Optional[float] = 0.031, tsurface: Optional[float] = 10, use_tgrad: Optional[bool] = False, useheatloss: Optional[bool] = False) -&gt; None\n</code></pre> <p>instantiate a dc1dwell object,  tvd, temp, salinity, skin, ahd, rw are arrays of length 2, first index is production well, second index is injection well</p> <p>:param k: permeability of the aquifer [mDarcy :param H: thickness of the aquifer [m] :param L: distance between the wells [m] :param tvd: true vertical depth of top of the reservoir in the wells [m] ndarray len = 2 :param temp: temperature of the wells ( tinj and tres) [C] ndarray len = 2 :param salinity: salinity [ppm] ndarray len = 2 :param skin: skin factor [-]  ndarray len = 2 :param ahd: along hole depth of the wells [m] up till the bottom of the reservoir, ndarray len = 2 :param rw: well radius  ndarray len = 2 :param roughness: roughness of the wells [ milli-inch ]</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.update_params","title":"update_params","text":"<pre><code>update_params(**kwargs) -&gt; None\n</code></pre> <p>update the parameters of the dc1dwell object :param kwargs:  parameter dictonary to update</p> <p>:return:</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.get_params","title":"get_params","text":"<pre><code>get_params() -&gt; Dict[str, Any]\n</code></pre> <p>get the parameters of the dc1dwell object :return: dictionary with the parameters of the dc1dwell object</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.from_configfile","title":"from_configfile  <code>classmethod</code>","text":"<pre><code>from_configfile(configfile: str) -&gt; Dc1dwell\n</code></pre> <p>create a dc1dwell object from a configfile</p> <p>:param configfile: yaml file with the parameters of the dc1dwell object :return: dc1dwell object</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.getPseudoKop","title":"getPseudoKop","text":"<pre><code>getPseudoKop() -&gt; float64\n</code></pre> <p>calculate the kick off depth for a linearized well trajectory, such that the Ahd for the top  corresponds to ahd = kod + sqrt( 0.25*L^2 + (tvd-kod)^2) :return:</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.calculateQvol","title":"calculateQvol","text":"<pre><code>calculateQvol(target_dp: int, initial_guess: Optional[float] = 0.05, tol: Optional[float] = 0.0001, max_iter: Optional[int] = 100) -&gt; float64\n</code></pre> <p>Use Newton-Raphson method to find the flow rate that results in the target pressure drop.</p> <p>:param target_dp: Target pressure drop :param initial_guess: Initial guess for the flow rate [m3/s] :param tol: Tolerance for the solution (default is 1e-4) :param max_iter: Maximum number of iterations :return: Flow rate that results in the target pressure drop</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.calculateDP_qvol","title":"calculateDP_qvol","text":"<pre><code>calculateDP_qvol() -&gt; None\n</code></pre> <p>calculate the pressure drop and production temperature of the wells for a given flow rate (if self.qvol is set to positive number) or it caluclates achievable flow rate and production temperature for the given flowrate :return: sets self.qvol or self.dp, and sets self.tprod.</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.productivity","title":"productivity","text":"<pre><code>productivity() -&gt; None\n</code></pre> <p>calculate the productivity index of the wells (i.e. pressure at reservoir level required for a unit flow rate [m3/s]</p> <p>:return: productivity index</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.dp_friction","title":"dp_friction","text":"<pre><code>dp_friction(qvol: Union[float, float64]) -&gt; None\n</code></pre> <p>calculate the frictional pressure drop in the wells</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.dp_syphon","title":"dp_syphon","text":"<pre><code>dp_syphon() -&gt; None\n</code></pre> <p>calculate the pressure in the well</p> <p>:return: pressure</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.Dc1dwell.tproduction","title":"tproduction","text":"<pre><code>tproduction() -&gt; float64\n</code></pre> <p>calculate the heat loss of the wells W/m, asusming one year of operation</p> <p>:param temp:  fluid temperature in the well :param tempenv: environmental temperature :param rw: well radius :return:</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.find_kod_binary_search","title":"find_kod_binary_search","text":"<pre><code>find_kod_binary_search(ahd: float64, L: int, tvd: float64, tol: Optional[float] = 1e-06, max_iter: Optional[int] = 1000) -&gt; float64\n</code></pre> <p>Find the solution for kod in the equation: ahd = kod + sqrt(0.25*L^2 + (tvd-kod)^2) using binary search.</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.find_kod_binary_search--parameters","title":"Parameters","text":"<p>ahd : float     Along hole depth. L : float     Distance between the wells. tvd : float     True vertical depth. tol : float, optional     Tolerance for the solution (default is 1e-6). max_iter : int, optional     Maximum number of iterations (default is 1000).</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.find_kod_binary_search--returns","title":"Returns","text":"<p>kod : float     Kick off depth.</p>"},{"location":"api/well_data/dc1d_well/#pywellgeo.well_data.dc1dwell.read_input","title":"read_input","text":"<pre><code>read_input(config: str) -&gt; Dict[str, Any]\n</code></pre> <p>Read .yml file with settings</p>"},{"location":"api/well_data/water_properties/","title":"pywellgeo.well_data","text":""},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties","title":"pywellgeo.well_data.water_properties","text":""},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties--waterproperties","title":"WaterProperties","text":"<p>This module contains functions to calculate various properties of water, such as viscosity, heat capacity, and density, based on temperature, pressure, and salinity.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties--functions","title":"Functions","text":"<p>viscosity(T, S)     Calculate water viscosity based on temperature and salinity.</p> <p>viscosityKestin(P, T, S)     Calculate water viscosity based on pressure, temperature, and salinity using Kestin's correlation.</p> <p>heatcapacity(T, S)     Calculate water heat capacity based on temperature and salinity.</p> <p>density(P, T, S)     Calculate water density based on pressure, temperature, and salinity.</p> <p>getWellPres(depth, T, S)     Calculate the bottom hole well pressure based on depth, temperature, and salinity.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.viscosity","title":"viscosity","text":"<pre><code>viscosity(T, S)\n</code></pre> <p>Calculate water viscosity.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.viscosity--parameters","title":"Parameters","text":"<p>T : float     Reservoir temperature in degrees Celsius. S : float     Salinity in ppm * 1e-6.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.viscosity--returns","title":"Returns","text":"<p>float     Viscosity in Pa s.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.viscosityKestin","title":"viscosityKestin","text":"<pre><code>viscosityKestin(P, T, S)\n</code></pre> <p>Calculate water viscosity using Kestin's correlation.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.viscosityKestin--parameters","title":"Parameters","text":"<p>P : float     Pressure in Pascal. T : float     Reservoir temperature in degrees Celsius. S : float     Salinity in ppm * 1e-6.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.viscosityKestin--returns","title":"Returns","text":"<p>float     Viscosity in Pa s.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.heatcapacity","title":"heatcapacity","text":"<pre><code>heatcapacity(T: Series, S: float) -&gt; Series\n</code></pre> <p>Calculate water heat capacity.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.heatcapacity--parameters","title":"Parameters","text":"<p>T : float     Reservoir temperature in degrees Celsius. S : float     Salinity in ppm * 1e-6.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.heatcapacity--returns","title":"Returns","text":"<p>float     Heat capacity in J kg-1 K-1.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.density","title":"density","text":"<pre><code>density(P: Series, T: Series, S: float) -&gt; Series\n</code></pre> <p>Calculate water density.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.density--parameters","title":"Parameters","text":"<p>P : float     Reservoir pressure in Pascal. T : float     Reservoir temperature in degrees Celsius. S : float     Salinity in ppm * 1e-6.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.density--returns","title":"Returns","text":"<p>float     Density in kg m-3.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.getWellPres","title":"getWellPres","text":"<pre><code>getWellPres(depth, T, S)\n</code></pre> <p>Calculate the bottom hole well pressure.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.getWellPres--parameters","title":"Parameters","text":"<p>depth : float     TVD of well in meters. T : float     Well temperature in degrees Celsius. S : float     Brine salinity in ppm * 1e-6.</p>"},{"location":"api/well_data/water_properties/#pywellgeo.well_data.water_properties.getWellPres--returns","title":"Returns","text":"<p>float     Bottom hole well pressure in bars.</p>"},{"location":"api/well_trajectory/trajectory/","title":"pywellgeo.welltrajectory","text":""},{"location":"api/well_trajectory/trajectory/#pywellgeo.welltrajectory.trajectory.Trajectory","title":"pywellgeo.welltrajectory.trajectory.Trajectory","text":"<p>Trajectory creates a trajectory database for all the wells, which can be based on a OPM input deck WXYZ or trajectory input file and detailed constructed well paths</p>"},{"location":"api/well_trajectory/trajectory/#pywellgeo.welltrajectory.trajectory.Trajectory.trajectoryinput","title":"trajectoryinput  <code>property</code>","text":"<pre><code>trajectoryinput: TrajectoryBase\n</code></pre> <p>contains the trajectory input object, and functionality to read the trajectory, as well as supplementary information   can :return:</p>"},{"location":"api/well_trajectory/trajectory/#pywellgeo.welltrajectory.trajectory.Trajectory.trajectoryinstance","title":"trajectoryinstance  <code>property</code>","text":"<pre><code>trajectoryinstance: None\n</code></pre> <p>contains the trajectory instance object where specific well geometrical aspects can be updated :return:</p>"},{"location":"api/well_trajectory/trajectory/#pywellgeo.welltrajectory.trajectory.Trajectory.__init__","title":"__init__","text":"<pre><code>__init__(trajectoryfile: str, options: GeothermalEconomicsConfig, simresults: Optional[BaseWellResults] = None, trajectoryinstance: Optional[Dict] = None) -&gt; None\n</code></pre> <p>:param geothermal_economics control file (instance of geothermal_economics.py) :param trajectoryfile: trajectory file (base settings for the well to inititatie the well path) :param trajectoryinstance: object instance whihc can be used to udpate geometrical aspects       of the well for raster asessment with varying depths, thickness etc</p>"},{"location":"api/well_trajectory/trajectory/#pywellgeo.welltrajectory.trajectory.Trajectory.read","title":"read","text":"<pre><code>read() -&gt; None\n</code></pre> <p>reads a grid from fname and gridIO object</p>"},{"location":"api/well_trajectory/trajectory_base/","title":"pywellgeo.welltrajectory","text":""},{"location":"api/well_trajectory/trajectory_base/#pywellgeo.welltrajectory.trajectory_base.TrajectoryBase","title":"pywellgeo.welltrajectory.trajectory_base.TrajectoryBase","text":"<p>TrajectoryBase creates the well trajectory from the control file WXYZ and platfrom data it does not support detailed well trajectory input files or trajectoryinstance varying with sample number this should be implemented in the read method of the derived class, currently only supported for TrajectoryDc1d.py</p>"},{"location":"api/well_trajectory/trajectory_base/#pywellgeo.welltrajectory.trajectory_base.TrajectoryBase.read","title":"read","text":"<pre><code>read(trajectoryfile: str, trajectoryinstance: Optional[Dc1dwell] = None) -&gt; Dict[str, Dict[str, Union[WellTreeTNO, Dict[str, float64]]]]\n</code></pre> <p>Base method for reading. Overwritten by all derived classes. Method signature differs between derived classes, but to use polymorphism later on the code full signature is as it is defined here. :param trajectoryfile: str, path to well trajectory file :param trajectoryinstance: Dc1dwell/Dict, instance of well trajectory object :return: Dict, dictionary containing all trajectories for all wells</p>"},{"location":"api/well_trajectory/trajectory_base/#pywellgeo.welltrajectory.trajectory_base.TrajectoryBase.getdefaultwellstates","title":"getdefaultwellstates","text":"<pre><code>getdefaultwellstates()\n</code></pre> <p>Get the default well states for the wells in the well trajectory</p> <p>:return: dictionary with the well names and the state of the well (prod or inj)</p>"},{"location":"api/well_trajectory/trajectory_base/#pywellgeo.welltrajectory.trajectory_base.TrajectoryBase.temploss_all","title":"temploss_all","text":"<pre><code>temploss_all(qvol: Series, templist: List[Series], salinity: Union[float, int], wells_and_states: Optional[Dict[str, str]] = None, reftime: int = 1, k: int = 3, at: Optional[float] = 1.2e-06, wellradius: Optional[float] = None) -&gt; List[Series]\n</code></pre> <p>Calculate the temeperature losses for the production wells in the well trajectory, for a given flowrate</p> <p>:param qvol: volumetric flow rate m3/s :param templist: temperature of the wells   in C :param salinity: fixed salinity in ppm :param wells_and_states: dictionary with the well names and the state of the well (prod or inj), same length as templist :param wellradius: radius of each of the wells, if None it will take the radius of the main wellbore :param reftime: reference time for the temperature losses in years :param k: rock thermal conductivity W/mK :param at: rock thermal diffusivity m2/s :return: temperature losses, list with same length as templist</p>"},{"location":"api/well_trajectory/trajectory_base/#pywellgeo.welltrajectory.trajectory_base.TrajectoryBase.temploss","title":"temploss","text":"<pre><code>temploss(well: str, qvols: Series, temp: Series, salinity: Union[float, int], time: int, k: int, at: float, wellradius: float) -&gt; Series\n</code></pre> <p>Calculate the production heat loss of the wells W/m, assuming one year of operation and taking the main branch as representative</p> <p>:param well: considered production well :param qvols: volumetric flow rate m3/s :param temp: bottom hole temperature of the well in C :param salinity: fixed salinity in ppm :param time: reference time for the temperature losses in seconds :param k: rock thermal conductivity W/mK :param at: rock thermal diffusivity m2/s :param wellradius: radius of the well in m :return: temperature losses in C :return:</p>"},{"location":"api/well_trajectory/trajectory_base/#pywellgeo.welltrajectory.trajectory_base.TrajectoryBase.friction_all","title":"friction_all","text":"<pre><code>friction_all(qvol: Series, templist: List[Series], salinity: float, tubingdiameter_inch: float, roughness_minch: float, wells_and_states: Optional[Dict[str, str]] = None) -&gt; Series\n</code></pre> <p>Calculate the friction losses for the wells in the well trajectory, for a given flowrate, for branching wells the flowrate is assumed to be equally distributed over the branches</p> <p>:param qvol: volumetric flow rate m3/s :param templist: temperature of the wells   in C :param salinity: fixed salinity in ppm :param tubingdiameter_inch: tubing diameter in inch of the wells :param roughness_minch: roughness in milli-inch of the wells :param wells_and_states: dictionary with the well names and the state of the well (prod or inj) :return: total pressure losses for flow rate in bar, but will store as members of the well trajectory          dpsum, dp_frictioninj,  dp_frictionprod, dpsyphon, dpsum = dp_frictioninj + dp_frictionprod + dpsyphon</p>"},{"location":"api/well_trajectory/trajectory_base/#pywellgeo.welltrajectory.trajectory_base.TrajectoryBase.friction","title":"friction","text":"<pre><code>friction(Qmass: Series, density: Series, viscosity: Series, tubingdiameter_inch: float, roughness_minch: float, well: str) -&gt; Series\n</code></pre> <p>The friction losses are calculated according to turbulent flow assuming a that all Qmass is flowing through the well. The algorithm takes into accoun that for the deeper sections flow can be divided over multiple branches. To this end, two section length with different flowrates are assumed. The first (main) section sustains all flow, the part wherte multiple branches occur the flow is assumed equally distributed over the number of existing branches in the well description</p> <p>:param Qmass: mass flow rate kg/s :param density:  density kg /m3 :param viscosity:  viscosity  Pas :param tubingdiameter_inch: tubing diameter in inch :param roughness_minch: roughness in milli-inch :param well: wellname :return: Pressure losses for flow rate bar</p>"},{"location":"api/well_trajectory/trajectory_base/#pywellgeo.welltrajectory.trajectory_base.TrajectoryBase.res_mainTVD","title":"res_mainTVD","text":"<pre><code>res_mainTVD(well: str) -&gt; float64\n</code></pre> <p>:param well: wellname :return: tvd of end of the main branch for the well</p>"},{"location":"api/well_trajectory/trajectory_base/#pywellgeo.welltrajectory.trajectory_base.TrajectoryBase.plot","title":"plot","text":"<pre><code>plot(fname: str)\n</code></pre> <p>Plot the well trajectory (the wells in the well trajectory, to the basename of the file (excluding extention)</p> <p>:param fname: filename</p>"},{"location":"api/well_trajectory/trajectory_dc1d/","title":"pywellgeo.welltrajectory","text":""},{"location":"api/well_trajectory/trajectory_dc1d/#pywellgeo.welltrajectory.trajectory_dc1d.TrajectoryDc1d","title":"pywellgeo.welltrajectory.trajectory_dc1d.TrajectoryDc1d","text":"<p>               Bases: <code>TrajectoryBase</code></p> <p>TrajectoryBase creates the well trajectory from a detaile dwell trajectory input file, as developed in RESULT, t includes</p>"},{"location":"api/well_trajectory/trajectory_dc1d/#pywellgeo.welltrajectory.trajectory_dc1d.TrajectoryDc1d.read","title":"read","text":"<pre><code>read(trajectoryfile: str, trajectoryinstance: Optional[Dc1dwell] = None) -&gt; Dict[str, Dict[str, Union[WellTreeTNO, Dict[str, float64]]]]\n</code></pre> <p>DC1DWell derived class implementation of read method. Read trajectory file, appends parameters, constructs WXYZ for each well and returns a dictionary with all well trajectories. :param trajectoryfile: str, path to well trajectory file :param trajectoryinstance: Dc1dwell/Dict, instance of well trajectory object :return: Dict, dictionary containing all trajectories for all wells</p>"},{"location":"api/well_trajectory/trajectory_detailed_tno/","title":"pywellgeo.welltrajectory","text":""},{"location":"api/well_trajectory/trajectory_detailed_tno/#pywellgeo.welltrajectory.trajectory_detailed_tno.TrajectoryDetailedTNO","title":"pywellgeo.welltrajectory.trajectory_detailed_tno.TrajectoryDetailedTNO","text":"<p>               Bases: <code>TrajectoryBase</code></p> <p>TrajectoryBase creates the well trajectory from a detaile dwell trajectory input file, as developed in RESULT, t includes</p>"},{"location":"api/well_trajectory/trajectory_detailed_tno/#pywellgeo.welltrajectory.trajectory_detailed_tno.TrajectoryDetailedTNO.read","title":"read","text":"<pre><code>read(trajectoryfile: str, trajectoryinstance: Optional[Dc1dwell] = None) -&gt; Dict[str, Dict[str, Union[Dict[str, Any], WellTreeTNO]]]\n</code></pre> <p>DetailedTno derived class implementation of read method. Reads the trajectory input and returns a dictionary with all well trajectories. :param trajectoryfile: str, path to well trajectory file :param trajectoryinstance: Dc1dwell/Dict, instance of well trajectory object :return: Dict, dictionary containing all trajectories for all wells</p>"},{"location":"api/well_trajectory/trajectory_factory/","title":"pywellgeo.welltrajectory","text":""},{"location":"api/well_trajectory/trajectory_factory/#pywellgeo.welltrajectory.trajectory_factory.TrajectoryFactory","title":"pywellgeo.welltrajectory.trajectory_factory.TrajectoryFactory","text":"<p>This  class is a factory for IO objects</p> <p>static Methods:</p> <pre><code> getTrajectoryClass (format: str) : gets an instance of the apppropriate Trajectory object\n</code></pre>"},{"location":"api/well_trajectory/trajectory_factory/#pywellgeo.welltrajectory.trajectory_factory.TrajectoryFactory.getTrajectoryClass","title":"getTrajectoryClass  <code>staticmethod</code>","text":"<pre><code>getTrajectoryClass(options: GeothermalEconomicsConfig, simresults: BaseWellResults, format: Optional[str] = 'BASE') -&gt; TrajectoryBase\n</code></pre> <p>Factory Method</p>"},{"location":"api/well_trajectory/trajectory_xyz_generic/","title":"pywellgeo.welltrajectory","text":""},{"location":"api/well_trajectory/trajectory_xyz_generic/#pywellgeo.welltrajectory.trajectory_xyz_generic.TrajectoryXyzGeneric","title":"pywellgeo.welltrajectory.trajectory_xyz_generic.TrajectoryXyzGeneric","text":"<p>               Bases: <code>TrajectoryBase</code></p> <p>TrajectoryBase creates the well trajectory from a detaile dwell trajectory input file, as developed in RESULT, t includes</p>"},{"location":"api/well_trajectory/trajectory_xyz_generic/#pywellgeo.welltrajectory.trajectory_xyz_generic.TrajectoryXyzGeneric.read","title":"read","text":"<pre><code>read(trajectoryfile: str, trajectoryinstance: Optional[Dc1dwell] = None) -&gt; Dict[str, Dict[str, Union[Dict[str, Any], WellTreeTNO]]]\n</code></pre> <p>DetailedTno derived class implementation of read method. Reads the trajectory input and returns a dictionary with all well trajectories. :param trajectoryfile: str, path to well trajectory file :param trajectoryinstance: Dc1dwell/Dict, instance of well trajectory object :return: Dict, dictionary containing all trajectories for all wells</p>"},{"location":"api/well_tree/well_tree_azim_dip/","title":"pywellgeo.well_tree","text":""},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip","title":"pywellgeo.well_tree.well_tree_azim_dip","text":""},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip","title":"WellTreeAzimDip","text":"<p>Well  Tree for well representation with multiple branches with azim dip notation the branches are the subsequent well bore subsegments, the representation is in x,y,z with curved segments which will be constructed from input yml. They are self explanatory in the sense that that consecutive (x,y,z) and (azim,dip) shooting directions are coplanar</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.from_input_trajectory","title":"from_input_trajectory  <code>classmethod</code>","text":"<pre><code>from_input_trajectory(input_trajectory: Dict[str, Dict[str, Dict[str, Union[str, Dict[str, int], float, Dict[str, Dict[str, int]]]]]], wellname: str) -&gt; 'WellTreeAzimDip'\n</code></pre> <p>compute tree branches from input yaml :param input_trajectory dictionary (yaml section of well_trajectories) :param wellname  wellname to consider</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.fromtargetXYZ","title":"fromtargetXYZ  <code>classmethod</code>","text":"<pre><code>fromtargetXYZ(nlast: 'WellTreeAzimDip', xnew: Union[int, int64], ynew: Union[int, int64], znew: Union[int, int64], radius: float, BUR: float, sname: Optional[str] = 'main', namesub: Optional[str] = 'sub') -&gt; 'WellTreeAzimDip'\n</code></pre> <p>get the plane normal from the self, and KOP to reach xnew, ynew,znew, from the end point to reach :param nlast  parent node :param xnew x-coordinate of point to reach :param ynew y-coordinate of point to reach :param znew z-coordinate of point to reach :param radius radius of the well segment :param BUR   build up rate of the segment :param sname name of the branch :param namesub name of the segment in the branch :returns WellTreeAzimDip node reprsenting the path</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.gettangent","title":"gettangent  <code>classmethod</code>","text":"<pre><code>gettangent(t2: CoordinateTransformation, xint: ndarray, radius: float) -&gt; Tuple[ndarray, AzimDip, float64]\n</code></pre> <p>this methods - assumes a local coordinate system with x-axis in the direction of ad (dip direction) and y along the strike, stored in t2 - xint is located in that plane - it finds the line tangent to the circle either centered at (0,-radius) or (0,radius) in the local coordinate system of the plane dipping in ad, from xint touching the circle. It is oriented such that shooting from xint, the subsequent arc segment results in the  orientation of ad - the tangent location and the abslute azimip of the tangent  (adtan) at that location is given, - and the inclination to be used of the plane direction relative to adtan</p> <p>:param radius: radius of the circle :return: tuple  xtan , adtan, inclination</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.fromAzimDipFromtargetXYZ","title":"fromAzimDipFromtargetXYZ  <code>classmethod</code>","text":"<pre><code>fromAzimDipFromtargetXYZ(nlast: 'WellTreeAzimDip', xnew: int, ynew: int, znew: int, azimnew: Optional[int], dipnew: int, radius: float, BUR: float, sname: Optional[str] = 'main', namesub: Optional[str] = 'sub') -&gt; 'WellTreeAzimDip'\n</code></pre> <p>get the plane normal, and KOP to reach xnew, ynew,znew, and either azimnew or dipnew :param nlast  parent node :param xnew x-coordinate of point to reach :param ynew y-coordinate of point to reach :param znew z-coordinate of point to reach :param azimnew azimuth (strike) for the wellbore to reach :param dipnew dip for the well bore to reach at x,y,a location :returns WellTreeAzimDip node reprsenting the path</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.findAzim","title":"findAzim  <code>classmethod</code>","text":"<pre><code>findAzim(plane: AzimDip, dip: int) -&gt; float64\n</code></pre> <p>find azimuth with the correct dip. It only considers a positive y value in the local coordinate system</p> <p>:param plane: plane containing the entry and exit of the path :param dip: target dip :return: azim azimuth of the exit trajectory</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.findDip","title":"findDip  <code>classmethod</code>","text":"<pre><code>findDip(tplane: AzimDip, azim)\n</code></pre> <p>find the dip at the specified direction of the azimuth of the well bore at the exit point in the plane starting from the entry point and azimdip direction</p> <p>:param tplane: plane containing the entry and exit of the path :param azim: azimuth direction to find dip for the exit :return: dip of vector on the tplane  which intersects with vertical plane at azim and of which innerproduct   with the azim strike is positive</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.read_input","title":"read_input  <code>classmethod</code>","text":"<pre><code>read_input(config: str) -&gt; Dict[str, Union[str, Dict[str, Dict[str, Union[float, int]]], Dict[str, Dict[str, Dict[str, Union[str, Dict[str, int], float, Dict[str, Dict[str, int]]]]]]]]\n</code></pre> <p>Read .yml file with settings</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.substitute_input","title":"substitute_input  <code>classmethod</code>","text":"<pre><code>substitute_input(inputs, subdict)\n</code></pre> <p>substitute items in subdict in inputs, not functioning at present</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.process_inputs","title":"process_inputs  <code>classmethod</code>","text":"<pre><code>process_inputs(inputname: str, wellname: str) -&gt; 'WellTreeAzimDip'\n</code></pre> <p>Process all input files</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.getCoordinateTransformation","title":"getCoordinateTransformation","text":"<pre><code>getCoordinateTransformation(doprint: Optional[bool] = False) -&gt; Tuple[CoordinateTransformation, AzimDip]\n</code></pre> <p>\" defines coordinate transformation in such a way that - the local x axis is positive in the direction of the previous azim/dip orientation, - the local x,y plane is spanned by  the vector   (self.x-xroot.x) and the azim/dip vector - the positive y aligns with the vector (self.x-xroot.x) :returns CoordinateTransformation object and the x,y plane in azim dip notation</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.getLocalCoordinates","title":"getLocalCoordinates","text":"<pre><code>getLocalCoordinates(md: float64, blist: List[WellTreeAzimDip], tlist: List[CoordinateTransformation]) -&gt; Tuple[int, ndarray, AzimDip, ndarray, AzimDip]\n</code></pre> <p>\" based on measured depth md (along hole depth)</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.WellTreeAzimDip.get_survey_EL","title":"get_survey_EL  <code>classmethod</code>","text":"<pre><code>get_survey_EL(trj, wname1, wname2, bname='main')\n</code></pre> <p>save the main branchs of 'well1' and 'well2' trajectory with name sbranch to survey points file :param trj : dictionary with well (branch) surveys :param wname1  first well to start survey data :param wname2 second well to extend survey data in reverse orde (the endpoint of wname1 and wname2 are expected correspond) :param bname branch name of the connected laterals :return: survey as dataframe</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.getKOP_L","title":"getKOP_L","text":"<pre><code>getKOP_L(bur: float, phi: float64, xoff: float64, zoff: float64) -&gt; Union[Tuple[int, int, int, float64, int], Tuple[float64, float64, float64, float64, float64]]\n</code></pre> <p>Compute KOP and  L specification for well in plane entering vertical at 0,0 and exiting at inclination phi at xoff, zoff</p> <p>:param  bur:  build up rate for the well, degrees per 30 m :param  phi: target inclination (degrees) of the well at xoff, zoff in range (0,180) :param  xoff:   off axis point of continuation of well trajectory (should be positive) :param  yoff:   in axis point of continuation of well trajectory (should be positive) :param  bur:  buildup rate of the well typically 3 degrees (per 30 m) :return:   tuple  A, xb, zb, KOP,  L</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.getKOP_L--notes","title":"notes","text":"<ul> <li>where A is arclength for the buildup,</li> <li>xb, zb are the horizontal and vertical spacing for the Buildup,</li> <li>KOP is Kickoff point and  L Length to reach xoff, zoff (such that xb+Lsin(phi)=xoff and zb+KOP +Lcos(phi)=zoff)</li> <li>total MD is equal to KOP + A + L</li> </ul>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.find_phi_L","title":"find_phi_L","text":"<pre><code>find_phi_L(dx, dz, bur=3.0)\n</code></pre> <p>Compute KOP, phi and L for  well in plane entering and exiting at same orientation (vertical in z direction) to reach  coordinates (0.5dx,0.5dz) starting from (0,0) phi is chosen as low possible value, based on dx (KOP close to 0) it also resurns xb and zb which are the horizontal and vertical spacing for the Buildup, and returns the arclength R for the build up</p> <p>:param  dx:  off axis shift of continuation of well trajectory (should be positive) :param  dz:   in axis shift of continuation of well trajectory (should be positive) :param  bur:  buildup rate of the well typically 3 degrees (per 30 m) :return tuple: phi, R, d1, v2, KOP, L to reach  coordinates (0.5dx,0.5dz) starting from 0,0</p>"},{"location":"api/well_tree/well_tree_azim_dip/#pywellgeo.well_tree.well_tree_azim_dip.find_phi","title":"find_phi","text":"<pre><code>find_phi(dx: float64, dz: float64, bur: Optional[float] = 3.0) -&gt; Tuple[float64, float64, float64, float64, float64, float64]\n</code></pre> <p>Compute  phi (pitch) such that with KOP is zero it also resurns xb and zb which are the horizontal and vertical spacing for the Buildup, and returns the arclength R for the build up</p> <p>:param  dx:   off axis shift of continuation of well trajectory (should be positive) :param  dz:   in axis shift of continuation of well trajectory (should be positive) :param  bur:  buildup rate of the well typically 3 degrees (per 30 m) :return:  tuple phi, R, d1, v2, KOP, L to reach  coordinates (0.5dx,0.5dz) starting from 0,0</p>"},{"location":"api/well_tree/well_tree_tno/","title":"pywellgeo.well_tree","text":""},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO","title":"pywellgeo.well_tree.well_tree_tno.WellTreeTNO","text":""},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.__init__","title":"__init__","text":"<pre><code>__init__(x: float64, y: float64, z: float64, radius: float, xroot: Optional['WellTreeTNO'] = None, perforated: Optional[bool] = True, color: Optional[str] = 'black', name: Optional[str] = 'main') -&gt; None\n</code></pre> <p>create a wellTree object, as a multiple linked list (allowing for multiple branches)</p> <p>:param x: np array (1d)  x coordinates :param y: nd array (1d)  y coordinates :param z: nd array (1d)  z coordinates :param radius: radius of the well :param xroot: connecting wellTree node (default is None :param perforated:  perforation status (default is True) :param color:   color of the wellTree node (default is black) :param name: name of the wellTree node (default is 'main')</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.copy","title":"copy  <code>classmethod</code>","text":"<pre><code>copy()\n</code></pre> <p>create a deep copy of the current instance :return: copy of the current instance</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.from_xyz","title":"from_xyz  <code>classmethod</code>","text":"<pre><code>from_xyz(x: ndarray, y: ndarray, z: ndarray, radius: Optional[float] = 0.10795, sname: Optional[str] = 'main', nroot: Optional['WellTreeTNO'] = None) -&gt; 'WellTreeTNO'\n</code></pre> <p>create a wellTree object from x,y,z coordinates</p> <p>:param x: np array (1d) with x coordinates :param y: np array (1d) with y coordinates :param z: np array (1d) with z coordinates :param radius: radius of the well :return: wellTree object, name is 'main'</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.add_xyz","title":"add_xyz","text":"<pre><code>add_xyz(x: ndarray, y: ndarray, z: ndarray, sbranch: Optional[str] = 'branch', color: Optional[str] = 'black', radius: Optional[float] = 0.10795) -&gt; None\n</code></pre> <p>add a branch to the well tree from x,y,z coordinates, it will insert the branch at the last point where the branch connects to the existing wellTree</p> <p>:param x: np array (1d) with x coordinates :param y: np array (1d) with y coordinates :param z: np array (1d) with z coordinates :param sbranch: name of the new branch :param color: color of the new branch :param radius: radius of the new branch</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.from_trajectories","title":"from_trajectories  <code>classmethod</code>","text":"<pre><code>from_trajectories(trajectory: Dict[str, DataFrame], radius: float) -&gt; 'WellTreeTNO'\n</code></pre> <p>obtain wellTree object from  'main' and trajectories 'branch1',  'branch2', etc from the well stored in dictionary trajectory from trajectory[branchname] and columns for 'x','y', 'TVD' (if branchname is 'main') else columns for branchname + '_x', branchname + '_y', branchname + '_TVD'. It will automatically remove any duplicate segements from branches above the kickoff point</p> <p>trajectory is created by the trajectories.py class from yml input</p> <p>:param trajectory: :param branchname: :param includebranchname: :return: wellTree for the well main and branches</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.from_vertical","title":"from_vertical  <code>classmethod</code>","text":"<pre><code>from_vertical(x, y, zmax, radius)\n</code></pre> <p>create a vertical wellTree object from x,y,z coordinates</p> <p>:param x: x coordinate :param y: y coordinate :param zmax: maximum z coordinate :param radius: radius of the well :return: wellTree object, name is 'main'</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.sameLocation","title":"sameLocation","text":"<pre><code>sameLocation(x: float64, y: float64, z: float64) -&gt; bool\n</code></pre> <p>check if the wellTree node is at the location x,y,z</p> <p>:param x: float :param y: float :param z: float :return: boolean if the wellTree node is at the location x,y,z</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.exist","title":"exist","text":"<pre><code>exist(x: float, y: float, z: float) -&gt; Union[Tuple[bool, None], Tuple[bool, WellTreeTNO]]\n</code></pre> <p>find the wellTree node in the wellTree which corresponds to the point with coordinates x,y,z</p> <p>:param x: float :param y: float :param z: float :return: boolean if the point exists, corresponding wellTree node</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.init_ahd","title":"init_ahd","text":"<pre><code>init_ahd() -&gt; None\n</code></pre> <p>initialize the along hole depth (AHD) for the wellTree</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.init_temperaturesoil","title":"init_temperaturesoil","text":"<pre><code>init_temperaturesoil(tsurface: float, tgrad: float) -&gt; None\n</code></pre> <p>initialize the Soil temperature surrounding the wellTree based on a surface temperature at Z=0 [C] and a temperature gradient [C/m]</p> <p>:param tsurface: surface temperature [C] :param tgrad: temperature gradient [C/m]</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.getAHDincrement","title":"getAHDincrement","text":"<pre><code>getAHDincrement() -&gt; float64\n</code></pre> <p>get the along hole depth increment for the current node</p> <p>:return: float ahdincrement</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.cumulative_ahd","title":"cumulative_ahd","text":"<pre><code>cumulative_ahd() -&gt; float64\n</code></pre> <p>find (cumulative) ahd of the branches from this node</p> <p>:return: ahd of the branches in the root</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.get_ahd","title":"get_ahd","text":"<pre><code>get_ahd(TVD: Union[float, int], branchname: Optional[str] = 'main') -&gt; float64\n</code></pre> <p>get the along hole depth (or MD)  of TVD, if it cannot be reached it returns the maximum AHD</p> <p>:param TVD: target true vertical depth :param branchname:  name of the branch to inspect, if it is not specified it follows the main branch :return: value of along hole depth corresponding to TVD</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.minmax","title":"minmax","text":"<pre><code>minmax(minx=None, maxx=None)\n</code></pre> <p>determine the min and max coordinates</p> <p>:param minx: min cooridnates tuple :param maxx: max coordinates tuple :return:</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.findlastsame","title":"findlastsame","text":"<pre><code>findlastsame(x: ndarray, y: ndarray, z: ndarray) -&gt; Tuple[WellTreeTNO, ndarray, ndarray, ndarray]\n</code></pre> <p>finds the first coordinates in x,y,z starting from the last index which match the existing wellTreeNode   if found it returns the wellTreeNode where the branch kicks off from existing wellTree   and it returns the sliced arrays of x,y,z, coordinates containing the branch from the kickoff point</p> <p>:param x: np array (1d) with x coordinates of branch trajectory :param y: np array (1d) with y coordinates of branch trajectory :param z: np array (1d) with z coordinates of branch trajectory :return: the kickoff wellTree node for the branch and sliced arrays starting from the kickoff point</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.get_xyzasnparay","title":"get_xyzasnparay  <code>staticmethod</code>","text":"<pre><code>get_xyzasnparay(trajectory: Dict[str, DataFrame], branchname: str, includebranchname: Optional[bool] = False) -&gt; Tuple[ndarray, ndarray, ndarray]\n</code></pre> <pre><code>obtain x,y,z coordinate arrays from specific branches (or main) from the well stored in dictionary trajectory\nfrom trajectory[branchname] and columns for 'x','y', 'TVD' (if includebranchname is False) else\ncolumns for branchname + '_x', branchname + '_y', branchname + '_TVD'\ntrajectory is created by the trajectories.py class from yml input\n</code></pre> <p>:param trajectory: :param branchname: :param includebranchname: :return: x,y,z numpy 1d arrays of coordinates (assuming ordered towards toe of well)</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.splitz","title":"splitz","text":"<pre><code>splitz(z)\n</code></pre> <p>split the well tree at depth z, adding z to the well tree if it is not already there</p> <p>:param z: depth to split the well tree</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.scale","title":"scale","text":"<pre><code>scale(scalevec)\n</code></pre> <p>scale the well tree by a vector scalevec</p> <p>:param scalevec: scale vector</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.coarsen","title":"coarsen","text":"<pre><code>coarsen(segmentlength=100, perforated=True)\n</code></pre> <p>coarsen the topology to the target segmentlength and only the (non)perforated section if perforated!=None</p> <p>:param segmentlength: target segment length (m), alonh hole depth :param perforated:   consider only (non) perforated section (if !=None) :return:</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.splitwell","title":"splitwell","text":"<pre><code>splitwell(ztop, zbase)\n</code></pre> <p>split the well tree to isolate the perforated section from ztop to zbase</p> <p>:param ztop: top coordinate (negative value) :param zbase: base coordinate (more negative value) :return:</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.setperforate","title":"setperforate","text":"<pre><code>setperforate(ztop, zbase)\n</code></pre> <p>set the perforation status of the well tree segments</p> <p>:param ztop: float top coordinate (negative value) :param zbase: float base coordinate (more negative value) :return:</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.perforate","title":"perforate","text":"<pre><code>perforate(ztop, zbase)\n</code></pre> <p>insert additional nodes to isolate the perforated section from ztop to zbottom, label the corresponding segments as perforated and color them blue</p> <p>:param ztop: top coordinate (negative value) :param zbase: bottom coordinate (more negative value)</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.condenseBranch","title":"condenseBranch  <code>staticmethod</code>","text":"<pre><code>condenseBranch(wlistin, segmentlength=10)\n</code></pre> <p>condense the branch to the target segment length</p> <p>:param wlistin: list of well tree nodes :param segmentlength:  target segment length :return:</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.getbranch","title":"getbranch","text":"<pre><code>getbranch(name: Optional[str] = None, perforated: Optional[bool] = True, includemain: Optional[bool] = False, wlist: Optional[List['WellTreeTNO']] = None) -&gt; None\n</code></pre> <p>collect the (perforated) segments in a list of welltree nodes, and begiining and ned points name and radius, this routine is used for the well index calculation</p> <p>:param name: name of the branch :param perforated: section (True or False) or ignored (perforated==None) :param includemain: include the main branch :param wlist: list of well tree nodes :return: dataframe with start and end points of the tree elements corresponding to name and perforated</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.getbranchlist","title":"getbranchlist","text":"<pre><code>getbranchlist(name: Optional[str] = None, perforated: Optional[bool] = True, includemain: Optional[bool] = False, wlist: Optional[List['WellTreeTNO']] = None) -&gt; List['WellTreeTNO']\n</code></pre> <p>collect the (perforated) segments in a list of welltree nodes, and begiining and ned points name and radius, this routine is used for the well index calculation</p> <p>:param name: name of the branch :param perforated: section (True or False) or ignored (perforated==None) :param includemain: include the main branch :param wlist: list of well tree nodes :return: list of well tree nodes correspondng to the name and perforated</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.getBranchSurvey","title":"getBranchSurvey","text":"<pre><code>getBranchSurvey(name=None, perforated=True, includemain=False, wlist=None)\n</code></pre> <p>collect survey points of selected  (perforated) segments</p> <p>:param name: name of the branch :param perforated: section (True or False) or ignored (perforated==None) :param includemain: include the main branch :param wlist: list of well tree nodes :return: dataframe with start and end points of the tree elements corresponding to name and perforated</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.temploss","title":"temploss","text":"<pre><code>temploss(wdot: Series, temp: Series, time: int, kt: int, at: float, wellradius: Optional[float] = None) -&gt; Series\n</code></pre> <p>calculate the temperature loss for the well branch</p> <p>:param wdot:  massflow * heat capacity rate (W/m3) :param time: reference time (s) :param kt: thermal conductivity (W/mK) :param at: thermal diffusivity (m2/s) :param wellradius: well radius (m) :return: temperature loss</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.plotTree3D","title":"plotTree3D","text":"<pre><code>plotTree3D(fig=None, ax=None, doplot=True, tofile=None)\n</code></pre> <p>plot the welltree in a 3D window</p> <p>:param fig: included only when appending to existing plot :param ax: included only when appending to existing plot :param doplot: if True the plot is finalized if False the result can be appended using return values in next call :param tofile: specify a file to save the resulting plot :return: fig, ax objects for next call when appending to existing (if doplot==False)</p>"},{"location":"api/well_tree/well_tree_tno/#pywellgeo.well_tree.well_tree_tno.WellTreeTNO.plotTree","title":"plotTree","text":"<pre><code>plotTree(fig=None, ax=None, axis=0)\n</code></pre> <p>plot the welltree in (x,y),  (x,z) or (y,z) plot</p> <p>:param fig: included only when appending to existing plot :param ax: included only when appending to existing plot :param axis: 0 means xy plot, 1 :return: fig, ax objects for next call when appending to existing (if doplot==False)</p>"}]}